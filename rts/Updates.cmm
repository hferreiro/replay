/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2004
 *
 * Code to perform updates.
 *
 * This file is written in a subset of C--, extended with various
 * features specific to GHC.  It is compiled by GHC directly.  For the
 * syntax of .cmm files, see the parser in ghc/compiler/cmm/CmmParse.y.
 *
 * ---------------------------------------------------------------------------*/


#include "Cmm.h"
#include "rts/prof/LDV.h"

#include "Updates.h"

/*
 * The update code is PERFORMANCE CRITICAL, if you make any changes
 * here make sure you eyeball the assembly and check that the fast
 * path (update in generation 0) is optimal.
 *
 * The return(ret) bit is passed down and pinned on the end of each
 * branch (there end up being two major branches in the code), since
 * we don't mind duplicating this jump.
 */
INFO_TABLE_RET ( stg_upd_frame, UPDATE_FRAME,
                 UPDATE_FRAME_FIELDS(W_,P_,info_ptr,_ccs,_unused,updatee) )
    return (P_ ret) /* the closure being returned */
{
    ASSERT(HpAlloc == 0); // Note [HpAlloc]

    /* ToDo: it might be a PAP, so we should check... */
    TICK_UPD_CON_IN_NEW(sizeW_fromITBL(%GET_STD_INFO(updatee)));

#ifdef DEBUG
    ccall debugReplay("cap %d: tso %d: upd_frame: update BH %p with %p (was %p)\n",
                      Capability_no(MyCapability()), StgTSO_id(CurrentTSO),
                      updatee "ptr", ret "ptr", StgInd_indirectee(updatee) "ptr");
#endif
    updateWithIndirection(updatee, ret, return (ret));
}

/*
 * An update frame where the updatee has been replaced by a BLACKHOLE
 * closure by threadPaused.  We may have threads to wake up, and we
 * also have to check whether the blackhole has been updated by
 * another thread in the meantime.
 */
INFO_TABLE_RET ( stg_marked_upd_frame, UPDATE_FRAME,
                 UPDATE_FRAME_FIELDS(W_,P_,info_ptr,_ccs,_unused,updatee) )
    return (P_ ret) /* the closure being returned */
{
    W_ v, ind;

    ASSERT(HpAlloc == 0); // Note [HpAlloc]

    // we know the closure is a BLACKHOLE
#if defined(REPLAY) && defined(THREADED_RTS)
    ind = StgInd_indirectee(updatee);
    ////if (CInt[replay_enabled] == 1 :: CInt && REPLAY_ATOM(ind) != 0) {
    //if (CInt[replay_enabled] == 1 :: CInt) {
    //    (v) = ccall replayMarkedUpdFrame(MyCapability() "ptr", updatee "ptr", ret "ptr", Hp "ptr");
    //    return (v);
    //}
    //// XXX: use TRACE_spark_full here and in StgCmmBind
    //if (REPLAY_ATOM(ind) != 0) {
    //    ASSERT(REPLAY_IS_BH(ind));
    //    if (REPLAY_ATOM(ind) == REPLAY_PTR_ATOM) {
    //        v = REPLAY_PTR(ind);
    //    // REPLAY_TSO_ATOM || REPLAY_SHARED_TSO
    //    } else {
    //        if (!REPLAY_IS_TSO(ind)) {
    //            ccall barf("Updates.cmm:stg_marked_upd_frame: not TSO");
    //        }
    //        (v) = ccall findThread(REPLAY_TSO(ind));
    //    }
    //} else {
        v = ind;
    //}
#else
    v = StgInd_indirectee(updatee);
#endif

    if (GETTAG(v) != 0) {
        // updated by someone else: discard our value and use the
        // other one to increase sharing, but check the blocking
        // queues to see if any threads were waiting on this BLACKHOLE.
#ifdef DEBUG
        ccall debugReplay("cap %d: tso %d: collision: %p -> %p already updated with %p [Hp = %p]\n",
                          Capability_no(MyCapability()), StgTSO_id(CurrentTSO),
                          updatee "ptr", ret "ptr", v "ptr", Hp "ptr");
#endif
#if defined(REPLAY) && defined(THREADED_RTS)
        if (CInt[TRACE_spark_full] == 1 :: CInt) {
            ccall replayTraceCapValue(MyCapability() "ptr", 29, updatee "ptr"); // COLLISION_WHNF
        }
#endif
        ccall checkBlockingQueues(MyCapability() "ptr", CurrentTSO "ptr");
        return (v);
    }

    // common case: it is still our BLACKHOLE
    if (v == CurrentTSO) {
#if defined(REPLAY) && defined(THREADED_RTS) && defined(DEBUG)
        ASSERT(REPLAY_ATOM(ind) != REPLAY_PTR_ATOM);
        //if (REPLAY_ATOM(ind) == REPLAY_SHARED_TSO) {
            ccall debugReplay("cap %d: tso %d: marked_upd_frame: update our BH %p -> %p with %p [Hp = %p]\n",
                              Capability_no(MyCapability()), StgTSO_id(CurrentTSO),
                              updatee "ptr", ind "ptr", ret "ptr", Hp "ptr");
        //}
#endif
        updateWithIndirection(updatee, ret, return (ret));
    }

#ifdef DEBUG
    ccall debugReplay("cap %d: tso %d: marked_upd_frame: other case updateThunk(%p, %p) [Hp = %p]\n",
                      Capability_no(MyCapability()), StgTSO_id(CurrentTSO),
                      updatee "ptr", ret "ptr", Hp "ptr");
#endif

    // The other cases are all handled by the generic code
    (v) = ccall updateThunk (MyCapability() "ptr", CurrentTSO "ptr",
                             updatee "ptr", ret "ptr");
#if defined(REPLAY) && defined(THREADED_RTS) && defined(DEBUG)
//    if (CInt[TRACE_spark_full] == 1 :: CInt && v != 0) {
//        ENTER(v);
//    }
#endif

    return (ret);
}

/*
 * Special update frame code for CAFs and eager-blackholed thunks: it
 * knows how to update blackholes, but is distinct from
 * stg_marked_upd_frame so that lazy blackholing won't treat it as the
 * high watermark.
 */
INFO_TABLE_RET ( stg_bh_upd_frame, UPDATE_FRAME,
                 UPDATE_FRAME_FIELDS(W_,P_,info_ptr,ccs,_unused,updatee) )
    return (P_ ret) /* the closure being returned */
{
#ifdef DEBUG
    ccall debugReplay("cap %d: tso %d: bh_upd_frame: %p %p\n",
                      Capability_no(MyCapability()), StgTSO_id(CurrentTSO),
                      updatee "ptr", ret "ptr");
#endif
    // This all compiles away to a single jump instruction (sigh)
    jump RET_LBL(stg_marked_upd_frame)
        ( UPDATE_FRAME_FIELDS(,,info_ptr,ccs,_unused,updatee) )
        (ret);
}

/* Note [HpAlloc]
 *
 * HpAlloc is required to be zero unless we just bumped Hp and failed
 * the heap check: see HeapStackCheck.cmm.  Failures that result from
 * HpAlloc being non-zero are very hard to track down, because they
 * manifest as spurious heap corruption that happens only with +RTS
 * -N2 or greater (because then we have a lot more
 * interruptCapability() calls happening).  Hence, we assert
 * HpAlloc==0 as often as possible, and in the update code is a good
 * place to do that.
 */
